import bcrypt from "bcryptjs";
import { userModel } from "../models/user.js";
import { nanoidNumbersOnly } from "../untils/nanoid.js";
import { jwtService } from "../config/jwt.js";
import { mailer } from "../config/nodemailer.js";

// B·ªô nh·ªõ t·∫°m l∆∞u m√£ x√°c th·ª±c
const verifyCodes = new Map();

/**
 * Controller x·ª≠ l√Ω c√°c API li√™n quan ƒë·∫øn ng∆∞·ªùi d√πng
 */
export const userController = {
  /**
   * L·∫•y danh s√°ch t·∫•t c·∫£ ng∆∞·ªùi d√πng
   */
  async getAllUsers(req, res) {
    try {
      const users = await userModel.getAllUsers();
      res.status(200).json(users);
    } catch (error) {
      console.error("Error getAllUsers:", error);
      res.status(500).json({ message: "L·ªói khi l·∫•y danh s√°ch ng∆∞·ªùi d√πng" });
    }
  },

  /**
   * L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo ID
   */
  async getUserById(req, res) {
    try {
      const { id } = req.params;
      const user = await userModel.getUserById(id);

      if (!user) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" });
      }
      res.status(200).json(user);
    } catch (error) {
      console.error("Error getUserById:", error);
      res.status(500).json({ message: "L·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng" });
    }
  },

  // üì® G·ª≠i m√£ x√°c nh·∫≠n email
  async sendVerifyCode(req, res) {
    try {
      const { email } = req.body;
      if (!email) return res.status(400).json({ message: "Thi·∫øu email" });

      const code = Math.floor(100000 + Math.random() * 900000).toString(); // m√£ 6 s·ªë
      verifyCodes.set(email, { code, expires: Date.now() + 5 * 60 * 1000 }); // h·∫øt h·∫°n 5 ph√∫t

      await mailer.sendMail({
        from: `"LaboSupport" <${process.env.MAIL_USER}>`,
        to: email,
        subject: "M√£ x√°c nh·∫≠n ƒëƒÉng k√Ω t√†i kho·∫£n",
        text: `M√£ x√°c nh·∫≠n c·ªßa b·∫°n l√†: ${code} (h·∫øt h·∫°n sau 5 ph√∫t)`,
      });

      res.status(200).json({ message: "ƒê√£ g·ª≠i m√£ x√°c nh·∫≠n qua email" });
    } catch (error) {
      console.error("Error sendVerifyCode:", error);
      res.status(500).json({ message: "L·ªói khi g·ª≠i m√£ x√°c nh·∫≠n" });
    }
  },



  // ‚úÖ ƒêƒÉng k√Ω ng∆∞·ªùi d√πng (ch·ªâ khi m√£ ƒë√∫ng)
  async register(req, res) {
    try {
      const { username, password, full_name, email, phone, role_id, verify_code } = req.body;

      if (!username || !password || !email || !verify_code)
        return res.status(400).json({ message: "Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt" });

      const record = verifyCodes.get(email);
      if (!record || record.code !== verify_code)
        return res.status(400).json({ message: "M√£ x√°c nh·∫≠n kh√¥ng ƒë√∫ng" });

      if (record.expires < Date.now()) {
        verifyCodes.delete(email);
        return res.status(400).json({ message: "M√£ x√°c nh·∫≠n ƒë√£ h·∫øt h·∫°n" });
      }

      const hashedPassword = await bcrypt.hash(password, 10);
      const newUser = {
        user_id: nanoidNumbersOnly(10),
        username,
        password: hashedPassword,
        full_name,
        email,
        phone,
        role_id: role_id || "1", // m·∫∑c ƒë·ªãnh Nh√¢n vi√™n
      };

      const created = await userModel.createUser(newUser);

      verifyCodes.delete(email);
      res.status(201).json({ message: "ƒêƒÉng k√Ω th√†nh c√¥ng", user: created });
    } catch (error) {
      console.error("Error register:", error);
      res.status(500).json({ message: "L·ªói khi ƒëƒÉng k√Ω ng∆∞·ªùi d√πng" });
    }
  },

  /**
   * C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
   */
  async updateUser(req, res) {
    try {
      const { id } = req.params;
      const data = req.body;

      const updated = await userModel.updateUser(id, data);
      if (!updated) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" });
      }

      res.status(200).json({ message: "C·∫≠p nh·∫≠t th√†nh c√¥ng" });
    } catch (error) {
      console.error("Error updateUser:", error);
      res.status(500).json({ message: "L·ªói khi c·∫≠p nh·∫≠t ng∆∞·ªùi d√πng" });
    }
  },

  /**
   * X√≥a ng∆∞·ªùi d√πng
   */
  async deleteUser(req, res) {
    try {
      const { id } = req.params;

      const deleted = await userModel.deleteUser(id);
      if (!deleted) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" });
      }

      res.status(200).json({ message: "X√≥a ng∆∞·ªùi d√πng th√†nh c√¥ng" });
    } catch (error) {
      console.error("Error deleteUser:", error);
      res.status(500).json({ message: "L·ªói khi x√≥a ng∆∞·ªùi d√πng" });
    }
  },

  /**
   * ƒêƒÉng nh·∫≠p ng∆∞·ªùi d√πng
   */
  async login(req, res) {
    try {
      const { username, password } = req.body;

      const user = await userModel.getUserByUsername(username);
      if (!user) {
        return res.status(401).json({ message: "Sai username ho·∫∑c password" });
      }

      const valid = await bcrypt.compare(password, user.password_hash);
      if (!valid) {
        return res.status(401).json({ message: "Sai username ho·∫∑c password" });
      }

      // T·∫°o token v·ªõi role
      const token = jwtService.generateToken({
        user_id: user.user_id,
        username: user.username,
        role_id: user.role_id,
        role_name: user.role_name,
      });

      res.status(200).json({
        message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng",
        token,
        user: {
          id: user.user_id,
          username: user.username,
          role: user.role_name || (user.role_id == 2 ? "admin" : "user"),
        },
      });
    } catch (error) {
      console.error("Error login:", error);
      res.status(500).json({ message: "L·ªói khi ƒëƒÉng nh·∫≠p" });
    }
  },

  async getAllUsersWithProfile() {
    const [rows] = await pool.query(`
    SELECT 
      u.user_id,
      u.username,
      u.full_name,
      u.email,
      u.phone,
      r.role_name
    FROM User u
    LEFT JOIN Role r ON u.role_id = r.role_id
  `);
    return rows;
  } 


};
